<html>
<head>
<title>
Eigenvalue Explorer
</title>
<style>
table#matrix {
background-color: #f1f1c1;
border: 1px solid black;
border-collapse: collapse;
}
tr:nth-child(even) {background-color: #92d2a2;}
h1 {
        text-align: center;
}
th, td {
    padding: 8px;
}
table#eigenvalues {
background-color: #f1f1c1;
border: 1px solid black;
border-collapse: collapse;
}

</style>
</head>

<body>

<H1>Eigenvalue Explorer</H1>
<H2>The Matrix</H2>
<p>
Here is a symmetric matrix:
<center>
<table id="matrix">
</table>
</center>
</p>

<p>
And these are its eigenvalues:

<center>
<table id="eigenvalues">
</table>
</center>
</p>

<p>
You can click on any element in the matrix and drag horizontally to increase or decrease its value.
As the matrix is symmetric, dragging an off-diagonal element will also modify its symmetrically opposite partner.
</p>

<p>
This diagram displays the eigenvalues graphically.
There is a vertical line for each eigenvalue.
The horizontal coordinate of the line represents the eigenvalue.
</p>

<p>
<center>
<canvas id="myCanvas" height="100" ; width="1000" style="border: solid 1px black;">Your browser does not support canvas.</canvas>
</center>
</p>

<p>
The main point I want to illustrate is that eigenvalues tend to avoid each other.
If the matrix is n by n, you have n(n+1)/2 matrix elements to play with, and only n eigenvalues, and yet it is tricky to get two eigenvalues to come out to be equal.
Sometimes two eigenvalues get really close and look like they're colliding, but if you look at the numerical values you'll see that what usually happens is that they just get close.
</p>

<H2>Random Matrices</H2>
<p>
This connects to the theory or random matrices.
If the elements of the matrix are generated at random from a normal distribution then the distribution of the eigenvalues is similar to the positions in a thermodynamic ensemble of electrically charged particles in a quadratic potential.
Because of the electric charge they will tend to repel each other. For example see <a href="https://arxiv.org/abs/1712.07903">Introduction to Random Matrices - Theory and Practice</a>.
</p>

<H2>Note</H2>
<p>
The algorithm used to compute the eigenvalues is the Jacobi method based on the pseudocode at <a href="https://en.wikipedia.org/wiki/Jacobi_eigenvalue_algorithm">Wikipedia</a>.
I think that pseudocode is buggy - for example it will divide by zero for an identity matrix.
So my code will probably occasionally divide by zero too.
</p>

<p>
I've tested this code only on Safari and Chrome on OSX.
</p>

<SCRIPT>

function makeMatrix(n) {
    a = new Array(n*n).fill(0.0);
    a.n = n;
    return a;
}

function copyMatrix(a) {
    n = a.n;
    b = new Array(n*n).fill(0.0);
    for (i = 0; i < n*n; ++i) {
        b[i] = a[i];
    }
    b.n = n;
    return b;
}

function makeIdentity(n) {
    a = makeMatrix(n);
    for (i = 0; i < n; ++i) {
        a[i*n+i] = 1.0;
    }
    return a;
}

function makeRandom(n) {
    a = makeMatrix(n);
    for (i = 0; i < n; ++i) {
        for (j = 0; j < n; ++j) {
            x = Math.random();
            a[i*n+j] = x;
            a[j*n+i] = x;
        }
    }
    return a;
}

function scaleVector(m, a) {
    n = a.length;
    b = new Array(n).fill(0.0);

    for (i = 0; i < n; ++i) {
        b[i] = m*a[i];
    }

    return b;
}

function multiplyMatrixVector(m, a) {
    b = new Array(n).fill(0.0);

    for (i = 0; i < n; ++i) {
        t = 0.0;
        for (j = 0; j < n; ++j) {
            t = t+m[n*i+j]*a[j];
        }
        b[i] = t;
    }

    return b;
}

// Jacobi eigenvalue algorithm

function jacobi(oldS) {
    var S = copyMatrix(oldS);
    n = S.n
    e = new Array(n).fill(0.0);
    changed = new Array(n).fill(true);
    ind = new Array(n).fill(0);

    // Index of largest off-diagonal element in row k
    function maxind(k) {
        m = k+1
        for (i = k+2; i < n; ++i) {
            if (Math.abs(S[n*k+i]) > Math.abs(S[n*k+m])) {
                m = i;
            }
        }
        return m
    }

    function update(k, t) {
        // console.log("update=", k, t);
        y = e[k];
        e[k] = y+t;
        if (changed[k] && y == e[k]) {
            changed[k] = false;
            --state;
        } else if (!changed[k] && y != e[k]) {
            changed[k] = true;
            ++state;
        }
    }

    function rotate(c, s, k, l, i, j) {
        tmp1 = c*S[n*k+l]-s*S[n*i+j];
        tmp2 = s*S[n*k+l]+c*S[n*i+j];
        S[n*k+l] = tmp1;
        S[n*i+j] = tmp2;
    }

    state = n;
    E = makeIdentity(n);

    for (k = 0; k < n; ++k) {
        ind[k] = maxind(k);
        e[k] = S[n*k+k];
    }

    maxIters = 200;
    iter = 0;
    while (state != 0 && iter < maxIters) {
        ++iter;

        // console.log("iter=", iter);
        // console.log("state=", state);

        // find index (k,l) of pivot p
        ++iter;

        // Looking for largest off-diagonal element here
        // console.log("Looking for max in ");
        // console.log(" "+S);
        m = 0;
        for (k = 1; k < n-1; ++k) {
            if (Math.abs(S[n*k+ind[k]]) > Math.abs(S[n*m+ind[m]])) {
                m = k;
            }
        }
        k = m;
        l = ind[m];
        p = S[n*k+l];
        // console.log("at k,l="+k+","+l+"   p="+p);

        // calculate c = cos φ, s = sin φ
        y = 0.5*(e[l]-e[k]);
        d = Math.abs(y)+Math.sqrt(p*p+y*y);
        // console.log("d=", d)
        r = Math.sqrt(p*p+d*d);
        c = d/r;
        s = p/r;
        t = p*p/d;

        if (y < 0) {
            s = -s;
            t = -t;
        }

        S[n*k+l] = 0.0;
        update(k, -t);
        update(l, t);

        // rotate rows and columns k and l
        for (i = 0; i < k; ++i) {
             rotate(c, s, i, k, i, l);
        }
        for (i = k+1; i < l; ++i) {
             rotate(c, s, k, i, i, l);
        }
        for (i = l+1; i < n; ++i) {
             rotate(c, s, k, i, l, i);
        }

        // rotate eigenvectors

        for (i = 0; i < n; ++i) {
            tmp1 = c*E[n*i+k]-s*E[n*i+l];
            tmp2 = s*E[n*i+k]+c*E[n*i+l];

            E[n*i+k] = tmp1;
            E[n*i+l] = tmp2;
        }

        // rows k, l have changed, update rows indk, indl
        ind[k] = maxind(k);
        ind[l] = maxind(l);
        // console.log("val at S[" + k + "," + ind[k] + "] = " + S[k*n+ind[k]]);
        // console.log("val at S[" + l + "," + ind[l] + "] = " + S[l*n+ind[l]]);
        // console.log("ind=", ind);
        // console.log("k,l=",k, l);
        // console.log("S=", S);
    }

    // console.log(E);
    // console.log("e=", e);

    // test
    for (q = 0; q < n; ++q) {
        v = new Array(n).fill(0.0);
        for (r = 0; r < n; ++r) {
            v[r] = E[n*r+q];
        }
        w = multiplyMatrixVector(oldS, v);
        z = scaleVector(e[q], v);
        // console.log("from:", v);
        // console.log("to:", w);
        // console.log("scaled:", z);
    }

    // I think it's an in-place sort
    e.sort(function (a, b) { return a-b; })

    return e;
}

/*
function mathematica(a) {
    n = a.n;
    r = "{";
    for (i = 0; i < n; ++i) {
        r = r+"{";
        for (j = 0; j < n; ++j) {
            r = r+a[i*n+j];
            if (j < n-1) {
                r = r+",";
            }
        }
        r = r+"}";
        if (i < n-1) {
            r = r+",";
        }
    }
    r = r+"}"
    return r;
}
*/

// End of Jacobi eigenvalue algorithm

digits = 3
n = 8
//S = makeMatrix(n);
//s = makeIdentity(4);
// console.log("S=" ,"m=" + mathematica(S));
//jacobi(S);

function displayEigenvalues(e) {
    canvas = document.getElementById("myCanvas");
    var ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (i = 0; i < n; ++i) {
        ctx.beginPath();
        ctx.lineTo(500+200*e[i],15);
        ctx.lineTo(500+200*e[i],85);
        ctx.stroke();
    }

    for (i = 0; i < n; ++i) {
        document.getElementById("e"+i).textContent = e[i].toFixed(digits);
    }
}

// Handle dragging of matrix element
function handleMove(ii, jj, elem) {
    return function(event) {
        x = document.getElementById(elem).textContent;
        // console.log(event)
        dx = event.movementX;
        dy = event.movementY;
        newx = parseFloat(x)+0.001*dx;
        document.getElementById(elem).textContent = newx.toFixed(digits);
        console.log("m"+jj+ii);
        document.getElementById("m"+jj+ii).textContent = newx.toFixed(digits);
        S[n*ii+jj] = newx;
        S[n*jj+ii] = newx;

        e = jacobi(S);
        // console.log("before sort:", e);
        // console.log("after sort:", e);

        displayEigenvalues(e);
    }
}

function handleDown(ii, jj, elem) {
    return function(event) {
        // console.log(elem);
        handler = handleMove(ii, jj, elem);
        document.addEventListener("mousemove", handler);

        document.addEventListener("mouseup", function() {
            document.removeEventListener("mousemove", handler);
        })
    }
}

function createMatrix(n) {
    var m = document.getElementById("matrix");
    var S = makeMatrix(n);
    for (var i = 0; i < n; ++i) {
        var tr = document.createElement("tr");
        for (j = 0; j < n; ++j) {
            if (j >= i) {
                // Generate new element
                x = Math.random()-0.5;
            } else {
                // Get partner element reflected in diagonal
                x = S[n*j+i];
            }

            S[n*i+j] = x;

            var td = document.createElement("td");
            name = "m"+i+j
            td.id = name
            var txt = document.createTextNode(x.toFixed(digits));

            td.appendChild(txt);
            tr.appendChild(td);

            td.addEventListener("mousedown", handleDown(i, j, name));
        }

        m.appendChild(tr);
    }

    return S;
}

function createEigenvalues(n, e) {
    var m = document.getElementById("eigenvalues");
    var tr = document.createElement("tr");
    for (i = 0; i < n; ++i) {
        var td = document.createElement("td");
        name = "e"+i
        td.id = name
        var txt = document.createTextNode(e[i].toFixed(digits));

        td.appendChild(txt);
        tr.appendChild(td);
    }

    m.appendChild(tr);
}

document.onselectstart = function() {
    return false;
}

S = createMatrix(n);
e = jacobi(S);
createEigenvalues(n, e)
displayEigenvalues(e);

</SCRIPT>

</body>
</html>
